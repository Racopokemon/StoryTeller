package rk.ramin.teller;

import java.awt.Component;
import java.awt.TextField;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;

import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.paint.Paint;

/**
 * This class has good reasons to be abstract: 
 * It provides the basic behavior of an areaMulti, dynamically creating and deleting elements and adding +- buttons to them, also managing
 * stuff like focus etc. 
 * But there are some problems that are only solved in the concrete subclasses:
 * All elements can be deleted from this AreaMulti, without anything happening if this happens. 
 * Also you will get errors if you add 
 */
public abstract class AreaMulti extends BoxBasic implements Area, AreaButtonAccepter, Saveable {

	private Constructor<? extends Node> constructor;
	protected boolean contentImplementsElement = false;
	private ConstructionData data;
	protected Box owner;
	protected ArrayList<Node> externalButtons = new ArrayList<>();
	
	private AreaMultiElementListener listener;
	
	public AreaMulti(boolean spacing, boolean useRim, boolean startsWithElement, Paint color, Class<? extends Node> elementClass, ConstructionData data, 
			Box box) {
		super(spacing, useRim, color);
		this.data = data;
		owner = box;
		try {
			constructor = elementClass.getConstructor(ConstructionData.class);
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Great job. Of course this works only with prepared element objects, that are only made to fit exactly this purpose. ");
		}
		if (Saveable.class.isAssignableFrom(elementClass)) {
			contentImplementsElement = true;
		}
		if (startsWithElement) {
			onButtonClicked(StyledButtonType.ADD_SMALL, null);
		}
	}
	
	@Override
	public void onButtonClicked(StyledButtonType type, ButtonProvider owner) {
		if (type == StyledButtonType.ADD_SMALL) {
			add(newElement(), owner);
		} else if (type == StyledButtonType.REMOVE_SMALL) {
			remove(owner);
		}
	}
	
	/**
	 * If you pass null as the nodeBefore, we simply add the node at the end of the element list. 
	 */
	public void add(ButtonProvider nodeToAdd, ButtonProvider nodeBefore) {
		if (nodeBefore == null) {
			box.getChildren().add(nodeToAdd);
		} else {
			box.getChildren().add(box.getChildren().indexOf(nodeBefore)+1, nodeToAdd);
		}
		if (listener != null) listener.onElementAdded(nodeToAdd.getNode()); 
		nodeToAdd.requestFocus();
	}
	
	/**
	 * You might receive exceptions if we don't contain this buttonProvider.
	 * So just don't do that. 
	 * 
	 * (If you give null, we will remove the last element. If we don't contain any elements, you will get an exception as well)
	 */
	public void remove(ButtonProvider remove) {
		ObservableList<Node> c = box.getChildren();
		if (remove == null) {
			remove = (ButtonProvider) c.get(c.size()-1);
		}
		int pos = c.indexOf(remove);
		if (box.getChildren().size() == 1) {
			impl_traverse(com.sun.javafx.scene.traversal.Direction.PREVIOUS);
			//((Node) owner.getPlaceForExternalButtons(this)).requestFocus();
		} //If not working anymore: Delete this test. For now it working amazing. Which idiot tagged this as deprecated? In swing we have it officially! Hopefully nobody deletes those ones in the future!
		box.getChildren().remove(remove);
		if (!c.isEmpty()) {
			if (pos == 0 && externalButtons.size() > 0) {
				((ButtonProvider)c.get(0)).addExternalButtons(externalButtons);
			}
			c.get(Math.min(pos, c.size()-1)).requestFocus();
		}
		if (listener != null) listener.onElementRemoved(remove.getNode()); 
	}
	
	/**
	 * Creates a ButtonProvider, containing a node generated by our constructor, with an +- button added. 
	 */
	protected ButtonProvider newElement() {
		ButtonProvider b = null;
		try {
			b = new ButtonProvider(constructor.newInstance(data), this);
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		b.addInternalCombinedButton();
		return b;
	}
	
	public void addExternalButton(Node n) {
		externalButtons.add(n);
	}
	public void addExternalButtons(ArrayList<Node> l) {
		externalButtons.addAll(l);
	}

	public void removeExternalButton(Node n) {
		int index = externalButtons.indexOf(n);
		externalButtons.remove(index);
	}
	public void removeExternalButtons(ArrayList<Node> l) {
		externalButtons.removeAll(l);
	}
	
	/**
	 * Your chance to give us one AreaMultiElementListener, that is notified every time an element is added or removed from this area.
	 * This will, after the listener is set, call a series of add-events - one for every element that we are currently containing!
	 * (No matter, which listener you give us, if you give the same listener again, it again will receive these calls, so be careful!)
	 */
	public void setListener(AreaMultiElementListener l) {
		listener = l;
		for (Node n : box.getChildren()) {
			l.onElementAdded(((ButtonProvider)n).getNode());
		}
	}
	
	@Override
	public Object save() {
		Object[] save = new Object[box.getChildren().size()];
		if (contentImplementsElement) { //Always, basically
			for (int i = box.getChildren().size()-1; i >= 0; i--) {
				save[i] = ((Saveable) (((ButtonProvider)(box.getChildren().get(i))).getNode())).save();
			}
		}
		return save;
	}

	@Override
	public void load(Object o) {
		List<Node> c = box.getChildren();
		Object[] ob = (Object[])o;
		while (c.size() < ob.length) {
			onButtonClicked(StyledButtonType.ADD_SMALL, null);
		}
		while (c.size() > ob.length) {
			onButtonClicked(StyledButtonType.REMOVE_SMALL, null);
		}
		if (contentImplementsElement) {
			for (int i = 0; i < ob.length; i++) {
				((Saveable)((ButtonProvider)c.get(i)).getNode()).load(ob[i]);
			}
		}
	}

	public void requestFocus() {
		if (box.getChildren().isEmpty()) {
			super.requestFocus();
		} else {
			box.getChildren().get(0).requestFocus();
		}
	}
}
